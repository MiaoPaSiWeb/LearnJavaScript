// 执行上下文(以下简称“上下文”)的概念在 JavaScript 中是颇为重要的。

// 变量或函数的上下文决定 了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象(variable object)， 
// 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台 处理数据会用到它。

// 全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一 样。
// 在浏览器中，全局上下文就是我们常说的 window 对象(第 12 章会详细介绍)，
// 因此所有通过 var 定 义的全局变量和函数都会成为 window 对象的属性和方法。
// 使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。
// 上下文在其所有代码都执行完毕后会被销毁，包括定义 在它上面的所有变量
// 和函数(全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器)。

// 每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。 在函数执
// 行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就
// 是通过这个上下文栈进行控制的。

// 上下文中的代码在执行的时候，会创建变量对象的一个作用域链(scope chain)。这个作用域链决定了各级上下文中
// 的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域 链的最前端。如果上下文是函数，
// 则其活动对象(activation object)用作变量对象。活动对象最初只有 一个定义变量:arguments。(全局上下文中没有这个变量。)
// 作用域链中的下一个变量对象来自包含上 下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文;
// 全局上下文的变量对象始终 是作用域链的最后一个变量对象。

// 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链 的最前端开始，
// 然后逐级往后，直到找到标识符。(如果没有找到标识符，那么通常会报错。)

// var color = "blue";
// function changeColor() {
//     if (color === "blue") {
//         color = "red";
//     } else {
//         color = "blue";
//     }
// }
// changeColor();

// 对这个例子而言，函数 changeColor()的作用域链包含两个对象:一个是它自己的变量对象(就 是定义 arguments 对象的
// 那个)，另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量 color，就是因为可以在作用域链中找到它。
// 此外，局部作用域中定义的变量可用于在局部上下文中替换全局变量。看一看下面这个例子:
var color = "blue";
function changeColor() {
    let anotherColor = "red";
    function swapColors() {
        let tempColor = anotherColor;
        anotherColor = color;
        color = tempColor;
        // 这里可以访问color、anotherColor和tempColor

    }
    // 这里可以访问color和anotherColor，但访问不到tempColor
    swapColors();
}
// 这里只能访问color 
changeColor();


//以上代码涉及 3 个上下文:全局上下文、changeColor()的局部上下文和 swapColors()的局部 上下文。
//全局上下文中有一个变量 color 和一个函数 changeColor()。
//changeColor()的局部上下文中 有一个变量 anotherColor 和一个函数 swapColors()，但在这里可以访问全局上下文中的变量 color。 
//swapColors()的局部上下文中有一个变量 tempColor，只能在这个上下文中访问到。
//全局上下文和 changeColor()的局部上下文都无法访问到 tempColor。而在 swapColors()中则可以访问另外两个 上下文中的变量，因为它们都是父上下文。




//作用域链增强
//虽然执行上下文主要有全局上下文和函数上下文两种(eval()调用内部存在第三种上下文)，但有 其他方式来增强作用域链。
//某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执 行后会被删除。通常在两种情况下会出现这个现象，
//即代码执行到下面任意一种情况时:
//  try/catch 语句的 catch 块
//  with 语句
// 这两种情况下，都会在作用域链前端添加一个变量对象。对 with 语句来说，会向作用域链前端添
// 加指定的对象;对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误 对象的声明。看下面的例子:
function buildUrl() {
    let qs = "?debug=true";
    with (location) {
        let url = href + qs;
    }
    return url;
}

// 这里，with 语句将 location 对象作为上下文，因此 location 会被添加到作用域链前端。 
// buildUrl()函数中定义了一个变量 qs。当 with 语句中的代码引用变量 href 时，实际上引用
// 的是 location.href，也就是自己变量对象的属性。在引用 qs 时，引用的则是定义在 buildUrl()中的
// 那 个变量，它定义在函数上下文的变量对象上。而在 with 语句中使用 var 声明的变量 url 会成
// 为函数 上下文的一部分，可以作为函数的值被返回;但像这里使用let声明的变量url，因为被限制在块级
// 作 用域(稍后介绍)，所以在 with 块之外没有定义。


/*
变量声明:

ES6 之后，JavaScript 的变量声明经历了翻天覆地的变化。
直到 ECMAScript 5.1，var 都是声明变量 的唯一关键字。ES6 不仅增加了 let 和 const 两个关键字，
而且还让这两个关键字压倒性地超越 var 成为首选。
*/

// 1. 使用 var 的函数作用域声明
// 在使用 var 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函 数的局
// 部上下文。在 with 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了， 那么它
// 就会自动被添加到全局上下文，如下面的例子所示:
// function add(num1, num2) {
//     var sum = num1 + num2;
//     return sum;
// }
// let result = add(10, 20); // 30
// console.log(sum); // 报错:sum 在这里不是有效变量


// 这里，函数 add()定义了一个局部变量 sum，保存加法操作的结果。这个值作为函数的值被返回， 
// 但变量 sum 在函数外部是访问不到的。如果省略上面例子中的关键字 var，那么 sum 在 add()被调用 
// 之后就变成可以访问的了，如下所示:
function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
let result = add(10, 20); // 30 
console.log(sum); // 30

// 这一次，变量 sum 被用加法操作的结果初始化时并没有使用 var 声明。在调用 add()之后，sum
// 被添加到了全局上下文，在函数退出之后依然存在，从而在后面可以访问到。

// var 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前。这个现象叫作“提升” (hoisting)。
// 提升让同一作用域中的代码不必考虑变量是否已经声明就可以直接使用。可是在实践中，提 升也会导致合法却奇怪的现象，
// 即在变量声明之前使用变量。下面的例子展示了在全局作用域中两段等价的代码:

 