// 在浏览器的发展史上，用到过两种主要的 标记策略:标记清理和引用计数。
`
============== 标记清理
JavaScript 最常用的垃圾回收策略是标记清理(mark-and-sweep)。当变量进入上下文，
比如在函数 内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，
逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时， 
也会被加上离开上下文的标记。

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位;
或者可以维护“在上下 文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移
到另一个列表。标记过程的实现 并不重要，关键是策略。
`
`
============== 引用计数
另一种没那么常用的垃圾回收策略是引用计数(reference counting)。其思路是对每个值都记录它被 引用的次数。
声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变 量，那么引用数加 1。
类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一 个值的引用数为 0 时，就说明没办法再访问到
这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为 0 的值的内存。
引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题:循环引用。
所谓循环引 用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。

`

setInterval(() => {
    
}, 10);

